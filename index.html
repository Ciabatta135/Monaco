<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Roblox Monaco Editor with Dynamic Tabs</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #1e1e2e;
      color: #fff;
      font-family: 'Fira Code', monospace;
    }

    #tabs {
      display: flex;
      background: #111827;
      padding: 0.5rem;
      overflow-x: auto;
      white-space: nowrap;
    }

    .tab {
      display: flex;
      align-items: center;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 6px 12px;
      margin-right: 4px;
      border-bottom: 2px solid transparent;
      position: relative;
    }

    .tab.active {
      border-color: #7aa2f7;
      font-weight: bold;
    }

    .tab .close-btn {
      margin-left: 8px;
      color: #aaa;
      font-weight: bold;
      cursor: pointer;
    }

    .tab .close-btn:hover {
      color: red;
    }

    #add-tab {
      background: none;
      border: none;
      color: #7aa2f7;
      font-size: 18px;
      cursor: pointer;
      padding: 6px 12px;
    }

    #container {
      width: 100%;
      height: calc(100% - 48px); /* Subtract tab bar height */
    }
  </style>
</head>
<body>
  <!-- Tab Bar -->
  <div id="tabs">
    <!-- Tabs will be inserted here dynamically -->
    <button id="add-tab" title="Add Tab">+</button>
  </div>

  <!-- Monaco Editor Container -->
  <div id="container"></div>

  <!-- Monaco Loader -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/loader.min.js"></script>
  <script>
    require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs' } });

    require(['vs/editor/editor.main'], function () {
      monaco.languages.register({ id: 'lua' });
      monaco.editor.defineTheme('lua-dark', {
        base: 'vs-dark',
        inherit: true,
        rules: [
          { token: 'keyword', foreground: 'bb9af7' },
          { token: 'type', foreground: '7aa2f7' },
          { token: 'operator', foreground: 'bb9af7' },
          { token: 'number', foreground: 'ff9e64' },
          { token: 'string', foreground: '9ece6a' },
          { token: 'comment', foreground: '565f89' },
          { token: 'delimiter', foreground: 'c0caf5' },
          { token: 'identifier', foreground: 'c0caf5' }
        ],
        colors: {
          'editor.background': '#1a1b26'
        }
      });

      // Editor instance and model map
      const models = {};
      let editor;
      let tabCounter = 1;
      let currentTabId = null;

      const tabsDiv = document.getElementById('tabs');
      const addTabBtn = document.getElementById('add-tab');

      function createTab() {
        const tabId = `tab${tabCounter++}`;
        const model = monaco.editor.createModel(`-- ${tabId}\nprint("New Lua tab")`, 'lua');
        models[tabId] = model;

        const tabButton = document.createElement('button');
        tabButton.className = 'tab';
        tabButton.id = tabId + '-btn';
        tabButton.innerHTML = `<span>${tabId}</span><span class="close-btn" onclick="closeTab(event, '${tabId}')">×</span>`;
        tabButton.onclick = () => switchTab(tabId);
        tabsDiv.insertBefore(tabButton, addTabBtn);

        switchTab(tabId);
      }

      function switchTab(tabId) {
        if (!models[tabId]) return;
        currentTabId = tabId;
        editor.setModel(models[tabId]);
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        const btn = document.getElementById(tabId + '-btn');
        if (btn) btn.classList.add('active');
      }

      window.closeTab = function (e, tabId) {
        e.stopPropagation(); // prevent triggering switch
        if (models[tabId]) {
          models[tabId].dispose();
          delete models[tabId];
        }

        const btn = document.getElementById(tabId + '-btn');
        if (btn) btn.remove();

        // Switch to another open tab if current one is closed
        if (currentTabId === tabId) {
          const remainingTabs = Object.keys(models);
          if (remainingTabs.length > 0) {
            switchTab(remainingTabs[0]);
          } else {
            editor.setModel(null);
            currentTabId = null;
          }
        }
      };

      addTabBtn.addEventListener('click', createTab);

      // Initialize editor
      editor = monaco.editor.create(document.getElementById('container'), {
        theme: 'lua-dark',
        fontSize: 14,
        minimap: { enabled: false }
      });

      // Add initial tab
      createTab();

      // Autocomplete
      monaco.languages.registerCompletionItemProvider('lua', {
        provideCompletionItems: () => ({
          suggestions: [
            { label: 'print', kind: monaco.languages.CompletionItemKind.Function, insertText: 'print(${1:text})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, documentation: "Outputs text to the console" },
            { label: 'Part.Anchored', kind: monaco.languages.CompletionItemKind.Property, insertText: 'Part.Anchored', documentation: "Property of class Part" },
            { label: 'Part.Size', kind: monaco.languages.CompletionItemKind.Property, insertText: 'Part.Size', documentation: "Property of class Part" },
            { label: 'Part.Position', kind: monaco.languages.CompletionItemKind.Property, insertText: 'Part.Position', documentation: "Property of class Part" },
            { label: 'Part.Destroy', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Part:Destroy()', documentation: "Function of class Part" },
            { label: 'Model.PrimaryPart', kind: monaco.languages.CompletionItemKind.Property, insertText: 'Model.PrimaryPart', documentation: "Property of class Model" },
            { label: 'Model.SetPrimaryPartCFrame', kind: monaco.languages.CompletionItemKind.Method, insertText: 'Model:SetPrimaryPartCFrame(${1:cframe})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, documentation: "Sets the model’s PrimaryPart CFrame" },
            { label: 'Enum.Material', kind: monaco.languages.CompletionItemKind.EnumMember, insertText: 'Enum.Material', documentation: 'Enum value Enum.Material' },
            { label: 'Enum.Font', kind: monaco.languages.CompletionItemKind.EnumMember, insertText: 'Enum.Font', documentation: 'Enum value Enum.Font' },
            { label: 'Enum.HumanoidStateType', kind: monaco.languages.CompletionItemKind.EnumMember, insertText: 'Enum.HumanoidStateType', documentation: 'Enum value Enum.HumanoidStateType' },
            { label: 'task.spawn', kind: monaco.languages.CompletionItemKind.Function, insertText: 'task.spawn(function()\n\t$0\nend)', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, documentation: 'Spawns a new task' },
            { label: 'game:GetService', kind: monaco.languages.CompletionItemKind.Method, insertText: 'game:GetService("${1:ServiceName}")', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, documentation: 'Returns a service from the game' }
          ]
        })
      });
    });
  </script>
</body>
</html>
